Оптимизация HTTP-сервера через версионность ресурсов. Пример реализации

СУТЬ ОПТИМИЗАЦИИ

Инженеры Yahoo в известной статье как-то упоминали об интересной технике оптимизации обработки HTTP через версионность файлов. Суть её такова... Обычно в HTML пишут просто:

< img src="image.jpg" >

Заполучив однажды image.jpg в кэш, после браузер снова считывает HTML и снова обнаруживает там ту же картинку. Понять обновилась ли она на сервере в общем случае браузер самостоятельно не может, так что ему придётся послать запрос на сервер.

Чтобы избежать лишнего запроса, можо указывать версию ресурса в его адресе, сделав адрес уникальным:

< img src="image.v250.jpg" >

Таким образом, браузер может быть уверен что файл версии №250 в будущем не поменяется, и №251 тоже; и если №250 есть в кэше, значит можно использовать его безо всяких вопросов к серверу. Чтобы указать на то что скачанным image.v250.jpg можно пользоваться пожизненно, сервер передаёт два HTTP-заголовка:

// Будте спокойны, картинка не обновится никогда
Expires: Fri, 30 Oct 2050 14:19:41 GMT
// и может хранится в кэше вечность
Cache-Control: max-age=12345678, public

Таким образом, для просмотра некой страницы в энный раз требуется только скачать HTML, а обращаться к многочисленным ресурсам уже не требуется.

PAGE LOAD vs REFRESH

В текущем виде эта оптимизация работает только для переходов по ссылке либо для Ctrl+L, Enter. Если пользователь обновляет текущую страницу (F5), то на сервер несутся запросы, по одному на каждый ресурс, и тут уже ничего не поделаешь. Единственное что можно и нужно сделать - не отвечать на эти запросы по полной программе, а говорить "у меня ничего не изменилось, возьмите из своего кэша".

Когда браузер запрашивает "image.v250.jpg", то в случае если у него в кэше есть копия, браузер посылает заголовок "If-Modified-Since: Fri, 01 Jan 1990 00:00:00 GMT". Браузер пришедший за этой картинкой в первый раз такой хидер не отпавляет. Соответственно, север должен первому говорить "ничего не изменилось", а второму честно отдать картинку. Конкретно в нашем случае дату можно не анализировать - важен сам факт наличия картинки в кэше, а картинка-то там верная (из-за версионности файлов и уникальных URL'ов).

Но просто так заголовок "If-Modified-Since" на сервер не придёт, даже если картинка лежит в кэше. Чтобы заставить браузер отправлять этот заголовок, в предыдущем ответе нужно было отдать заголовок "Last-Modified: Fri, 01 Jan 1990 00:00:00 GMT". На практике это всего лишь означает что этот заголовок сервер должен отдавать всегда. Можно отдавать честную дату последнего изменения файла, а можно указать любую дату в прошлом - эта же дата потом пойдёт на сервер, а там она не представляет интереса.

По сути, описываемая в этом параграфе оптимизация прямого отношения к Yahoo'вской не имеет, но должна использоваться вместе с той, чтобы избежать лишних нагрузки. Иначе эффект будет неполным.

ПОТРЕБУЕТСЯ АВТОМАТИЗАЦИЯ

Техника неплохая, но расставлять версии файлов вручную на практике маловозможно. В GAE/django проблема решается через custom tags. В шаблоне пишется такой код:

<code><pre>< img src="{% static 'image.jpg' %}" ></pre></code>

преобразующийся в:

<code><pre>< img src="image.123456.jpg" ></pre></code>

И вот реализация такого тэга:

<code><pre>def static(path):
    return StaticFilesInfo.get_resource_path(path)
register.simple_tag(static)</pre></code>

РЕАЛИЗАЦИЯ ЧЕРВЕРНОЙ ЧАСТИ

ОПТИМИЗАЦИЯ СЕРВЕРНОЙ ЧАСТИ

В качестве версии файла можно использовать как версию из VCS, так и время последнего обновления файла - тут принципиальной разницы нет. Я выбрал второе, да с ним и попроще:

os.path.getmtime(file)

Однако опрашивать файловую систему на каждый запрос вроде бы не очень хорошо - I/O всегда медленный. Поэтому можно собрать информацию о текущих версиях (всех) статических файлах при первом запросе и положить её в memcache. На выходе получается такой хэш:

{ 'cover.jpg': 123456, 'style.css': 234567 }

Этот хэш и будет использоваться в custom tag'е для нахождения последней версии.