Оптимизация HTTP-сервера через версионность ресурсов. Пример реализации

СУТЬ ОПТИМИЗАЦИИ

Инженеры Yahoo в известной статье как-то упоминали об интересной технике оптимизации обработки HTTP через версионность файлов. Суть её такова... Обычно в HTML пишут просто:

< img src="image.jpg" >

Заполучив однажды image.jpg в кэш, после браузер снова считывает HTML и снова обнаруживает там ту же картинку. Понять обновилась ли она на сервере в общем случае браузер самостоятельно не может, так что ему придётся послать запрос на сервер.

Чтобы избежать лишнего запроса, можо указывать версию ресурса в его адресе, сделав адрес уникальным:

< img src="image.v250.jpg" >

Таким образом, браузер может быть уверен что файл версии №250 в будущем не поменяется, и №251 тоже; и если №250 есть в кэше, значит можно использовать его безо всяких вопросов к серверу. Чтобы указать на то что скачанным image.v250.jpg можно пользоваться пожизненно, сервер передаёт два HTTP-заголовка:

// Будте спокойны, картинка не обновится никогда
Expires: Fri, 30 Oct 2050 14:19:41 GMT
// и может хранится в кэше вечность
Cache-Control: max-age=12345678, public

Таким образом, для просмотра некой страницы в энный раз требуется только скачать HTML, а обращаться к многочисленным ресурсам уже не требуется.

PAGE LOAD vs REFRESH

В текущем виде эта оптимизация работает только для переходов по ссылке либо для Ctrl+L, Enter. Если пользователь обновляет текущую страницу (F5), то на сервер несутся запросы, по одному на каждый ресурс, и тут уже ничего не поделаешь. Единственное что можно и нужно сделать - не отвечать на эти запросы по полной программе, а говорить "у меня ничего не изменилось, возьмите из своего кэша".

Когда браузер запрашивает "image.v250.jpg", то в случае если у него в кэше есть копия, браузер посылает заголовок "If-Modified-Since: Fri, 01 Jan 1990 00:00:00 GMT". Браузер пришедший за этой картинкой в первый раз такой хидер не отпавляет. Соответственно, север должен первому говорить "ничего не изменилось", а второму честно отдать картинку. Конкретно в нашем случае дату можно не анализировать - важен сам факт наличия картинки в кэше, а картинка-то там верная (из-за версионности файлов и уникальных URL'ов).

Но просто так заголовок "If-Modified-Since" на сервер не придёт, даже если картинка лежит в кэше. Чтобы заставить браузер отправлять этот заголовок, в предыдущем ответе нужно было отдать заголовок "Last-Modified: Fri, 01 Jan 1990 00:00:00 GMT". На практике это всего лишь означает что этот заголовок сервер должен отдавать всегда. Можно отдавать честную дату последнего изменения файла, а можно указать любую дату в прошлом - эта же дата потом пойдёт на сервер, а там она не представляет интереса.

По сути, описываемая в этом параграфе оптимизация прямого отношения к Yahoo'вской не имеет, но должна использоваться вместе с той, чтобы избежать лишних нагрузки. Иначе эффект будет неполным.

ПОТРЕБУЕТСЯ АВТОМАТИЗАЦИЯ

Техника неплохая, но расставлять версии файлов вручную на практике маловозможно. В GAE/django проблема решается через custom tags. В шаблоне пишется такой код:

<code><pre>< img src="{% static 'image.jpg' %}" ></pre></code>

преобразующийся в:

<code><pre>< img src="image.123456.jpg" ></pre></code>

И вот реализация такого тэга:

<code><pre>def static(path):
    return StaticFilesInfo.get_resource_path(path)
register.simple_tag(static)</pre></code>

РЕАЛИЗАЦИЯ ЧЕРВЕРНОЙ ЧАСТИ

ОПТИМИЗАЦИЯ СЕРВЕРНОЙ ЧАСТИ

В качестве версии файла можно использовать как версию из VCS, так и время последнего обновления файла - тут принципиальной разницы нет. Я выбрал второе, да с ним и попроще:

<code><pre>os.path.getmtime(file)</pre></code>

Однако опрашивать файловую систему на каждый запрос вроде бы не очень хорошо - I/O всегда медленный. Поэтому можно собрать информацию о текущих версиях (всех) статических файлах при первом запросе и положить информацию в memcache. На выходе получается такой хэш:

<code><pre>{ 'cover.jpg': 123456, 'style.css': 234567 }</pre></code>

Который и будет использоваться в custom tag'е для нахождения последней версии. Естественно, понадобится что-то вроде синглтона на случай если memcache протухнет:

<code><pre>
class StaticFilesInfo():
    @classmethod
    def __get_static_files_info(cls):
        info = memcache.get(cls.__name__)
        if info is None:
            info = cls.__grab_info()
            time = MEMCACHE_TIME_PRODUCTION if is_production() else MEMCACHE_TIME_DEV_SERVER
            memcache.set(cls.__name__, info, time)
        return info
    @classmethod
	def __grab_info(cls):
		"""
		Obtain info about all files in managed 'static' directory.
		This is done rarely.
		"""
		dir = os.path.join(os.path.split(__file__)[0], WHERE_STATIC_FILES_ARE_STORED)
		hash = {}
		for file in os.listdir(dir):
			abs_file = os.path.join(dir, file)
			hash[file] = int(os.path.getmtime(abs_file))
		return hash
</pre></code>
		
ОСОБЕННОСТИ GOOGLE APP ENGINE

Можно собрать информацию о всех статических файлах, но что если дизайнер изменит картинку? Как сервер узнает что пора обновить закэшированные версии файлов? В общем случае не очень себе представляю - нужно, наврено, заводить демона слушающего изменения файловой системы.

Но App Engine - система особенная. В этой системе разработка ведётся на локальной машине, после чего готовый код (и статические файлы) разворачиваются (деплоятся) на сервер. И, что важно, файлы на сервере уже не могут быть изменены (до следующего деплоя). То есть достаточно считать версии лишь однажды и более не заботиться о том что версии могут поменяться.

Единственное, при локальной разработке файлы меняться очень даже могут, и если в данном случае не действовать альтернативно, браузер будет, например, показывать разработчику старую версию изображения что неудобно. Но в этом случае производительности неважна, так что можно класть данные в memcache на считанные секунды или не класть вовсе.